import type { AddEnvironmentClusterExecArgs, DeleteEnvironmentExecArgs, InitializeEnvironmentExecArgs, RemoveEnvironmentClusterExecArgs } from '@/plugins/hooks/environment.js'
import { addDestinationToApplicationProject, createApplicationProject, deleteApplicationProject, removeDestinationFromApplicationProject } from './app-project.js'
import { createApplication, deleteApplication } from './applications.js'
import type { PluginResult, StepCall } from '@/plugins/hooks/hook.js'
import type { CreateRepositoryExecArgs, DeleteRepositoryExecArgs } from '@/plugins/hooks/repository.js'

export const newEnv: StepCall<InitializeEnvironmentExecArgs> = async (payload) => {
  try {
    const { project, organization, environment, repositories } = payload.args
    // @ts-ignore keycloak is generated by keycloak plugin
    const { roGroup, rwGroup } = payload.keycloak
    const namespace = `${organization}-${project}-${environment}`

    const appProjectName = `${organization}-${project}-${environment}-project`
    await createApplicationProject({ appProjectName, roGroup, rwGroup, repositories })

    for (const repo of repositories) {
      const applicationName = `${organization}-${project}-${repo.internalRepoName}-${environment}`
      await createApplication({ applicationName, appProjectName, namespace, repo })
    }
    return {
      status: {
        result: 'OK',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Can\'t create env',
      },
      error: JSON.stringify(error),
    }
  }
}

export const deleteEnv: StepCall<DeleteEnvironmentExecArgs> = async (payload) => {
  try {
    const { project, organization, environment, repositories } = payload.args

    const appProjectName = `${organization}-${project}-${environment}-project`
    await deleteApplicationProject({ appProjectName })
    for (const repo of repositories) {
      const applicationName = `${organization}-${project}-${repo.internalRepoName}-${environment}`
      await deleteApplication({ applicationName, repoUrl: repo.url })
    }
    return {
      status: {
        result: 'OK',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Failed',
      },
      error: JSON.stringify(error),
    }
  }
}

const nothingStatus: PluginResult = {
  status: {
    result: 'OK',
    message: 'Not an infra repository',
  },
}

export const newRepo: StepCall<CreateRepositoryExecArgs> = async (payload) => {
  try {
    if (!payload.args.isInfra) return nothingStatus
    const repo = { internalRepoName: payload.args.internalRepoName, url: payload.args.internalUrl }
    const { project, organization, environments } = payload.args

    for (const env of environments) {
      const roGroup = `/${organization}-${project}/${env}/RO`
      const rwGroup = `/${organization}-${project}/${env}/RW`
      const namespace = `${organization}-${project}-${env}`
      const appProjectName = `${organization}-${project}-${env}-project`
      const applicationName = `${organization}-${project}-${repo.internalRepoName}-${env}`
      await createApplicationProject({ appProjectName, roGroup, rwGroup, repositories: [] })
      await createApplication({ applicationName, appProjectName, namespace, repo })
    }
    return {
      status: {
        result: 'OK',
        message: 'Created',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Failed',
      },
      error: JSON.stringify(error),
    }
  }
}

export const deleteRepo: StepCall<DeleteRepositoryExecArgs> = async (payload) => {
  if (!payload.args.isInfra) return nothingStatus

  try {
    const { project, organization, environments, internalRepoName, internalUrl } = payload.args

    for (const env of environments) {
      const appProjectName = `${organization}-${project}-${env}-project`
      const applicationName = `${organization}-${project}-${internalRepoName}-${env}`
      await deleteApplication({ applicationName, repoUrl: internalUrl })
      await deleteApplicationProject({ appProjectName })
    }
    return {
      status: {
        result: 'OK',
        message: 'Deleted',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Failed',
      },
      error: JSON.stringify(error),
    }
  }
}

export const addCluster: StepCall<AddEnvironmentClusterExecArgs> = async (payload) => {
  try {
    const { project, organization, environment, cluster } = payload.args

    const appProjectName = `${organization}-${project}-${environment}-project`
    const namespace = `${organization}-${project}-${environment}`
    await addDestinationToApplicationProject(appProjectName, { namespace, name: cluster.label, server: cluster.cluster.server })
    return {
      status: {
        result: 'OK',
        message: 'Added',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Failed',
      },
      error: JSON.stringify(error),
    }
  }
}

export const removeCluster: StepCall<RemoveEnvironmentClusterExecArgs> = async (payload) => {
  try {
    const { project, organization, environment, cluster } = payload.args

    const appProjectName = `${organization}-${project}-${environment}-project`
    await removeDestinationFromApplicationProject(appProjectName, cluster.label)
    return {
      status: {
        result: 'OK',
        message: 'Deleted',
      },
    }
  } catch (error) {
    return {
      status: {
        result: 'KO',
        message: 'Failed',
      },
      error: JSON.stringify(error),
    }
  }
}
